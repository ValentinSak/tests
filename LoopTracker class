# Implement the LoopTracker class. When creating an instance of the class, it should accept one argument:
# - iterable: the iterable object.
# An instance of the LoopTracker class should be an iterator that generates elements from the iterable object in their original order and then raises a StopIteration exception.
# The LoopTracker class should have four properties:
  # - accesses: a read-only property that returns the number of elements generated by the iterator so far.
  # - empty_accesses: a read-only property that returns the number of attempts to retrieve the next element from an empty iterator.
  # - first: a read-only property that returns the first element of the iterator without advancing it. 
  # If the iterator doesn't have a first element, i.e., it is created from an empty iterable object, an AttributeError with the text "Source iterable object is empty" should be raised.
  # - last: a read-only property that returns the last element generated by the iterator so far. 
  # If the iterator hasn't generated any elements yet, an AttributeError with the text "No last element" should be raised.
# The LoopTracker class should have one instance method:
  # - is_empty(): a method that returns True if the iterator is empty or False otherwise.
# Note 1: Additional data validation is not required in the methods. It is guaranteed that the implemented class will only be used with valid data.
# Note 2: The LoopTracker class should adhere to the iterator protocol, i.e., it should have the methods iter() and next(). 

# Here is my code (I thionk it's a good one):

class LoopTracker:
    def __init__(self, iterable):
        self.iterable = iter(iterable)
        self.collection = list(iterable)
        self.length = len(list(iterable))
        self.counter = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.counter += 1
        return next(self.iterable)

    @property
    def accesses(self):
        if self.counter <= self.length:
            return self.counter
        return self.length

    @property
    def empty_accesses(self):
        if self.counter > self.length:
            return self.counter - self.length
        return 0

    @property
    def first(self):
        if self.collection:
            return self.collection[0]
        raise AttributeError('Source iterable object is empty')

    @property
    def last(self):
        if self.counter == 0:
            raise AttributeError('No last element')
        return self.collection[self.counter - 1]

    def is_empty(self):
        if self.counter >= self.length:
            return True
        return False




